-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language grammar.

module AbsGrammar where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

type Program = Program' BNFC'Position
data Program' a = Prog a [FunDecl' a] (Main' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Main = Main' BNFC'Position
data Main' a = DMain a (Block' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunDecl = FunDecl' BNFC'Position
data FunDecl' a = DFun a (Type' a) Ident [ArgDecl' a] (Block' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Decl = Decl' BNFC'Position
data Decl' a
    = DFunDecl a (FunDecl' a)
    | DVarDecl a (Type' a) Ident (Exp' a)
    | DConstVarDecl a (Type' a) Ident (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ArgDecl = ArgDecl' BNFC'Position
data ArgDecl' a
    = DArgDecl a (Type' a) Ident | DConstArgDecl a (Type' a) Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Block = Block' BNFC'Position
data Block' a = IBlock a [Decl' a] [Instr' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Instr = Instr' BNFC'Position
data Instr' a
    = IAss a Ident (Exp' a)
    | IIf a (Exp' a) (Instr' a) (Else' a)
    | IWhile a (Exp' a) (Instr' a)
    | IPrStr a (Exp' a)
    | IRet a (Exp' a)
    | IBreak a
    | IRaise a Ident
    | IContinue a
    | ITryBlock a (Block' a) Ident [Ident] (Block' a)
    | IBlockInstr a (Block' a)
    | IExp a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Else = Else' BNFC'Position
data Else' a = IElseEmpty a | IElse a (Instr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Exp = Exp' BNFC'Position
data Exp' a
    = EOr a (Exp' a) (Exp' a)
    | IAnd a (Exp' a) (Exp' a)
    | EEq a (Exp' a) (Exp' a)
    | ENeq a (Exp' a) (Exp' a)
    | ELeq a (Exp' a) (Exp' a)
    | EGeq a (Exp' a) (Exp' a)
    | ELess a (Exp' a) (Exp' a)
    | EGrt a (Exp' a) (Exp' a)
    | EPlus a (Exp' a) (Exp' a)
    | ENeg a Integer
    | EMinus a (Exp' a) (Exp' a)
    | EConcat a (Exp' a) (Exp' a)
    | ETimes a (Exp' a) (Exp' a)
    | EDiv a (Exp' a) (Exp' a)
    | ENot a (Exp' a)
    | EInt a Integer
    | EBool a (Bool' a)
    | EStr a String
    | EIdent a Ident
    | EFuncall a Ident [Arg' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Arg = Arg' BNFC'Position
data Arg' a = AVal a (Exp' a) | ARef a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Type = Type' BNFC'Position
data Type' a = TBool a | TInt a | TStr a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Bool = Bool' BNFC'Position
data Bool' a = BTrue a | BFalse a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Program where
  hasPosition = \case
    Prog p _ _ -> p

instance HasPosition Main where
  hasPosition = \case
    DMain p _ -> p

instance HasPosition FunDecl where
  hasPosition = \case
    DFun p _ _ _ _ -> p

instance HasPosition Decl where
  hasPosition = \case
    DFunDecl p _ -> p
    DVarDecl p _ _ _ -> p
    DConstVarDecl p _ _ _ -> p

instance HasPosition ArgDecl where
  hasPosition = \case
    DArgDecl p _ _ -> p
    DConstArgDecl p _ _ -> p

instance HasPosition Block where
  hasPosition = \case
    IBlock p _ _ -> p

instance HasPosition Instr where
  hasPosition = \case
    IAss p _ _ -> p
    IIf p _ _ _ -> p
    IWhile p _ _ -> p
    IPrStr p _ -> p
    IRet p _ -> p
    IBreak p -> p
    IRaise p _ -> p
    IContinue p -> p
    ITryBlock p _ _ _ _ -> p
    IBlockInstr p _ -> p
    IExp p _ -> p

instance HasPosition Else where
  hasPosition = \case
    IElseEmpty p -> p
    IElse p _ -> p

instance HasPosition Exp where
  hasPosition = \case
    EOr p _ _ -> p
    IAnd p _ _ -> p
    EEq p _ _ -> p
    ENeq p _ _ -> p
    ELeq p _ _ -> p
    EGeq p _ _ -> p
    ELess p _ _ -> p
    EGrt p _ _ -> p
    EPlus p _ _ -> p
    ENeg p _ -> p
    EMinus p _ _ -> p
    EConcat p _ _ -> p
    ETimes p _ _ -> p
    EDiv p _ _ -> p
    ENot p _ -> p
    EInt p _ -> p
    EBool p _ -> p
    EStr p _ -> p
    EIdent p _ -> p
    EFuncall p _ _ -> p

instance HasPosition Arg where
  hasPosition = \case
    AVal p _ -> p
    ARef p _ -> p

instance HasPosition Type where
  hasPosition = \case
    TBool p -> p
    TInt p -> p
    TStr p -> p

instance HasPosition Bool where
  hasPosition = \case
    BTrue p -> p
    BFalse p -> p

