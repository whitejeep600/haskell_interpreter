-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParGrammar
  ( happyError
  , myLexer
  , pProgram
  , pMain
  , pFunDecl
  , pDecl
  , pArgDecl
  , pListArgDecl
  , pBlock
  , pInstr
  , pElse
  , pListInstr
  , pExp
  , pExp1
  , pExp2
  , pExp3
  , pExp4
  , pExp5
  , pExp6
  , pListArg
  , pArg
  , pListIdent
  , pListDecl
  , pListFunDecl
  , pType
  , pBool
  ) where

import Prelude

import qualified AbsGrammar
import LexGrammar

}

%name pProgram_internal Program
%name pMain_internal Main
%name pFunDecl_internal FunDecl
%name pDecl_internal Decl
%name pArgDecl_internal ArgDecl
%name pListArgDecl_internal ListArgDecl
%name pBlock_internal Block
%name pInstr_internal Instr
%name pElse_internal Else
%name pListInstr_internal ListInstr
%name pExp_internal Exp
%name pExp1_internal Exp1
%name pExp2_internal Exp2
%name pExp3_internal Exp3
%name pExp4_internal Exp4
%name pExp5_internal Exp5
%name pExp6_internal Exp6
%name pListArg_internal ListArg
%name pArg_internal Arg
%name pListIdent_internal ListIdent
%name pListDecl_internal ListDecl
%name pListFunDecl_internal ListFunDecl
%name pType_internal Type
%name pBool_internal Bool
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)  }
  '#'        { PT _ (TS _ 2)  }
  '('        { PT _ (TS _ 3)  }
  ')'        { PT _ (TS _ 4)  }
  '*'        { PT _ (TS _ 5)  }
  '+'        { PT _ (TS _ 6)  }
  ','        { PT _ (TS _ 7)  }
  '-'        { PT _ (TS _ 8)  }
  '/'        { PT _ (TS _ 9)  }
  ';'        { PT _ (TS _ 10) }
  '<'        { PT _ (TS _ 11) }
  '<='       { PT _ (TS _ 12) }
  '='        { PT _ (TS _ 13) }
  '=='       { PT _ (TS _ 14) }
  '>'        { PT _ (TS _ 15) }
  '>='       { PT _ (TS _ 16) }
  'and'      { PT _ (TS _ 17) }
  'bool'     { PT _ (TS _ 18) }
  'break'    { PT _ (TS _ 19) }
  'const'    { PT _ (TS _ 20) }
  'continue' { PT _ (TS _ 21) }
  'def'      { PT _ (TS _ 22) }
  'do'       { PT _ (TS _ 23) }
  'else'     { PT _ (TS _ 24) }
  'except'   { PT _ (TS _ 25) }
  'false'    { PT _ (TS _ 26) }
  'fi'       { PT _ (TS _ 27) }
  'if'       { PT _ (TS _ 28) }
  'int'      { PT _ (TS _ 29) }
  'main'     { PT _ (TS _ 30) }
  'not'      { PT _ (TS _ 31) }
  'or'       { PT _ (TS _ 32) }
  'print'    { PT _ (TS _ 33) }
  'raise'    { PT _ (TS _ 34) }
  'ref'      { PT _ (TS _ 35) }
  'return'   { PT _ (TS _ 36) }
  'str'      { PT _ (TS _ 37) }
  'then'     { PT _ (TS _ 38) }
  'true'     { PT _ (TS _ 39) }
  'try'      { PT _ (TS _ 40) }
  'while'    { PT _ (TS _ 41) }
  '{'        { PT _ (TS _ 42) }
  '}'        { PT _ (TS _ 43) }
  L_Ident    { PT _ (TV _)    }
  L_integ    { PT _ (TI _)    }
  L_quoted   { PT _ (TL _)    }

%%

Ident :: { (AbsGrammar.BNFC'Position, AbsGrammar.Ident) }
Ident  : L_Ident { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.Ident (tokenText $1)) }

Integer :: { (AbsGrammar.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (AbsGrammar.BNFC'Position, String) }
String   : L_quoted { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

Program :: { (AbsGrammar.BNFC'Position, AbsGrammar.Program) }
Program
  : ListFunDecl Main { (fst $1, AbsGrammar.Prog (fst $1) (snd $1) (snd $2)) }

Main :: { (AbsGrammar.BNFC'Position, AbsGrammar.Main) }
Main
  : 'main' Block { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.DMain (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }

FunDecl :: { (AbsGrammar.BNFC'Position, AbsGrammar.FunDecl) }
FunDecl
  : 'def' Type Ident '(' ListArgDecl ')' Block { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.DFun (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5) (snd $7)) }

Decl :: { (AbsGrammar.BNFC'Position, AbsGrammar.Decl) }
Decl
  : FunDecl { (fst $1, AbsGrammar.DFunDecl (fst $1) (snd $1)) }
  | Type Ident '=' Exp ';' { (fst $1, AbsGrammar.DVarDecl (fst $1) (snd $1) (snd $2) (snd $4)) }
  | 'const' Type Ident '=' Exp ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.DConstVarDecl (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5)) }

ArgDecl :: { (AbsGrammar.BNFC'Position, AbsGrammar.ArgDecl) }
ArgDecl
  : Type Ident { (fst $1, AbsGrammar.DArgDecl (fst $1) (snd $1) (snd $2)) }
  | 'const' Type Ident { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.DConstArgDecl (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }

ListArgDecl :: { (AbsGrammar.BNFC'Position, [AbsGrammar.ArgDecl]) }
ListArgDecl
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, []) }
  | ArgDecl { (fst $1, (:[]) (snd $1)) }
  | ArgDecl ',' ListArgDecl { (fst $1, (:) (snd $1) (snd $3)) }

Block :: { (AbsGrammar.BNFC'Position, AbsGrammar.Block) }
Block
  : '{' ListDecl ListInstr '}' ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IBlock (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }

Instr :: { (AbsGrammar.BNFC'Position, AbsGrammar.Instr) }
Instr
  : Ident '=' Exp ';' { (fst $1, AbsGrammar.IAss (fst $1) (snd $1) (snd $3)) }
  | 'if' Exp 'then' Instr Else 'fi' ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IIf (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $5)) }
  | 'while' Exp 'do' Instr { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IWhile (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'print' Exp ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IPrStr (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'return' Exp ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IRet (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'break' ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IBreak (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }
  | 'raise' Ident ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IRaise (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'continue' ';' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IContinue (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }
  | 'try' Block 'except' Ident ListIdent Block { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.ITryBlock (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $5) (snd $6)) }
  | Block { (fst $1, AbsGrammar.IBlockInstr (fst $1) (snd $1)) }
  | Exp ';' { (fst $1, AbsGrammar.IExp (fst $1) (snd $1)) }

Else :: { (AbsGrammar.BNFC'Position, AbsGrammar.Else) }
Else
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, AbsGrammar.IElseEmpty AbsGrammar.BNFC'NoPosition) }
  | 'else' Instr { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.IElse (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListInstr :: { (AbsGrammar.BNFC'Position, [AbsGrammar.Instr]) }
ListInstr
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, []) }
  | Instr ListInstr { (fst $1, (:) (snd $1) (snd $2)) }

Exp :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp
  : Exp1 'or' Exp { (fst $1, AbsGrammar.EOr (fst $1) (snd $1) (snd $3)) }
  | Exp1 { (fst $1, (snd $1)) }

Exp1 :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp1
  : Exp2 'and' Exp1 { (fst $1, AbsGrammar.EAnd (fst $1) (snd $1) (snd $3)) }
  | Exp2 { (fst $1, (snd $1)) }

Exp2 :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp2
  : Exp3 '==' Exp3 { (fst $1, AbsGrammar.EEq (fst $1) (snd $1) (snd $3)) }
  | Exp3 '!=' Exp3 { (fst $1, AbsGrammar.ENeq (fst $1) (snd $1) (snd $3)) }
  | Exp3 '<=' Exp3 { (fst $1, AbsGrammar.ELeq (fst $1) (snd $1) (snd $3)) }
  | Exp3 '>=' Exp3 { (fst $1, AbsGrammar.EGeq (fst $1) (snd $1) (snd $3)) }
  | Exp3 '<' Exp3 { (fst $1, AbsGrammar.ELess (fst $1) (snd $1) (snd $3)) }
  | Exp3 '>' Exp3 { (fst $1, AbsGrammar.EGrt (fst $1) (snd $1) (snd $3)) }
  | Exp3 { (fst $1, (snd $1)) }

Exp3 :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp3
  : Exp3 '+' Exp4 { (fst $1, AbsGrammar.EPlus (fst $1) (snd $1) (snd $3)) }
  | Exp3 '-' Exp4 { (fst $1, AbsGrammar.EMinus (fst $1) (snd $1) (snd $3)) }
  | Exp3 '#' Exp4 { (fst $1, AbsGrammar.EConcat (fst $1) (snd $1) (snd $3)) }
  | Exp4 { (fst $1, (snd $1)) }

Exp4 :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp4
  : Exp4 '*' Exp5 { (fst $1, AbsGrammar.ETimes (fst $1) (snd $1) (snd $3)) }
  | Exp4 '/' Exp5 { (fst $1, AbsGrammar.EDiv (fst $1) (snd $1) (snd $3)) }
  | Exp5 { (fst $1, (snd $1)) }

Exp5 :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp5
  : '-' Integer { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.ENeg (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'not' Exp6 { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.ENot (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Exp6 { (fst $1, (snd $1)) }

Exp6 :: { (AbsGrammar.BNFC'Position, AbsGrammar.Exp) }
Exp6
  : Integer { (fst $1, AbsGrammar.EInt (fst $1) (snd $1)) }
  | Bool { (fst $1, AbsGrammar.EBool (fst $1) (snd $1)) }
  | String { (fst $1, AbsGrammar.EStr (fst $1) (snd $1)) }
  | Ident { (fst $1, AbsGrammar.EIdent (fst $1) (snd $1)) }
  | Ident '(' ListArg ')' { (fst $1, AbsGrammar.EFuncall (fst $1) (snd $1) (snd $3)) }
  | '(' Exp ')' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListArg :: { (AbsGrammar.BNFC'Position, [AbsGrammar.Arg]) }
ListArg
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, []) }
  | Arg { (fst $1, (:[]) (snd $1)) }
  | Arg ',' ListArg { (fst $1, (:) (snd $1) (snd $3)) }

Arg :: { (AbsGrammar.BNFC'Position, AbsGrammar.Arg) }
Arg
  : Exp { (fst $1, AbsGrammar.AVal (fst $1) (snd $1)) }
  | 'ref' Ident { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.ARef (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListIdent :: { (AbsGrammar.BNFC'Position, [AbsGrammar.Ident]) }
ListIdent
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, []) }
  | Ident { (fst $1, (:[]) (snd $1)) }
  | Ident ',' ListIdent { (fst $1, (:) (snd $1) (snd $3)) }

ListDecl :: { (AbsGrammar.BNFC'Position, [AbsGrammar.Decl]) }
ListDecl
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, []) }
  | Decl ListDecl { (fst $1, (:) (snd $1) (snd $2)) }

ListFunDecl :: { (AbsGrammar.BNFC'Position, [AbsGrammar.FunDecl]) }
ListFunDecl
  : {- empty -} { (AbsGrammar.BNFC'NoPosition, []) }
  | FunDecl ListFunDecl { (fst $1, (:) (snd $1) (snd $2)) }

Type :: { (AbsGrammar.BNFC'Position, AbsGrammar.Type) }
Type
  : 'bool' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.TBool (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }
  | 'int' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.TInt (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }
  | 'str' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.TStr (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }

Bool :: { (AbsGrammar.BNFC'Position, AbsGrammar.Bool) }
Bool
  : 'true' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.BTrue (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }
  | 'false' { (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1), AbsGrammar.BFalse (uncurry AbsGrammar.BNFC'Position (tokenLineCol $1))) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err AbsGrammar.Program
pProgram = fmap snd . pProgram_internal

pMain :: [Token] -> Err AbsGrammar.Main
pMain = fmap snd . pMain_internal

pFunDecl :: [Token] -> Err AbsGrammar.FunDecl
pFunDecl = fmap snd . pFunDecl_internal

pDecl :: [Token] -> Err AbsGrammar.Decl
pDecl = fmap snd . pDecl_internal

pArgDecl :: [Token] -> Err AbsGrammar.ArgDecl
pArgDecl = fmap snd . pArgDecl_internal

pListArgDecl :: [Token] -> Err [AbsGrammar.ArgDecl]
pListArgDecl = fmap snd . pListArgDecl_internal

pBlock :: [Token] -> Err AbsGrammar.Block
pBlock = fmap snd . pBlock_internal

pInstr :: [Token] -> Err AbsGrammar.Instr
pInstr = fmap snd . pInstr_internal

pElse :: [Token] -> Err AbsGrammar.Else
pElse = fmap snd . pElse_internal

pListInstr :: [Token] -> Err [AbsGrammar.Instr]
pListInstr = fmap snd . pListInstr_internal

pExp :: [Token] -> Err AbsGrammar.Exp
pExp = fmap snd . pExp_internal

pExp1 :: [Token] -> Err AbsGrammar.Exp
pExp1 = fmap snd . pExp1_internal

pExp2 :: [Token] -> Err AbsGrammar.Exp
pExp2 = fmap snd . pExp2_internal

pExp3 :: [Token] -> Err AbsGrammar.Exp
pExp3 = fmap snd . pExp3_internal

pExp4 :: [Token] -> Err AbsGrammar.Exp
pExp4 = fmap snd . pExp4_internal

pExp5 :: [Token] -> Err AbsGrammar.Exp
pExp5 = fmap snd . pExp5_internal

pExp6 :: [Token] -> Err AbsGrammar.Exp
pExp6 = fmap snd . pExp6_internal

pListArg :: [Token] -> Err [AbsGrammar.Arg]
pListArg = fmap snd . pListArg_internal

pArg :: [Token] -> Err AbsGrammar.Arg
pArg = fmap snd . pArg_internal

pListIdent :: [Token] -> Err [AbsGrammar.Ident]
pListIdent = fmap snd . pListIdent_internal

pListDecl :: [Token] -> Err [AbsGrammar.Decl]
pListDecl = fmap snd . pListDecl_internal

pListFunDecl :: [Token] -> Err [AbsGrammar.FunDecl]
pListFunDecl = fmap snd . pListFunDecl_internal

pType :: [Token] -> Err AbsGrammar.Type
pType = fmap snd . pType_internal

pBool :: [Token] -> Err AbsGrammar.Bool
pBool = fmap snd . pBool_internal
}

